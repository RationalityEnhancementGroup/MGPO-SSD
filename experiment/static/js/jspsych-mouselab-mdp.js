// Generated by CoffeeScript 2.4.1, edited directly by Lovis Heindrich
  /*
  jspsych-mouselab-mdp.coffee
  Fred Callaway

  https://github.com/fredcallaway/Mouselab-MDP
  */
var D, SCORE, TIME_LEFT, WATCH, mdp,
  indexOf = [].indexOf;

var disablepan = false
// coffeelint: disable=max_line_length
mdp = void 0;

D = void 0;

WATCH = {};

SCORE = 0;

TIME_LEFT = void 0;

jsPsych.plugins['mouselab-mdp'] = (function() {
  var Arrow, Edge, KEYS, LOG_DEBUG, LOG_INFO, MouselabMDP, NULL, PRINT, RIGHT_MESSAGE, SIZE, State, TOP_ADJUST, EXTRA_TOP_ADJUST, EXTRA_LEFT_ADJUST, TRIAL_INDEX, Text, angle, checkObj, dist, plugin, polarMove, redGreen, removePrivate, round;
  PRINT = function(...args) {
    return console.log(...args);
  };
  NULL = function(...args) {
    return null;
  };
  LOG_INFO = PRINT;
  LOG_DEBUG = NULL;
  // a scaling parameter, determines size of drawn objects
  SIZE = void 0;
  TRIAL_INDEX = 0;
  TOP_ADJUST = -25;
  EXTRA_TOP_ADJUST = -200;
  EXTRA_LEFT_ADJUST = -25;
  fabric.Object.prototype.originX = fabric.Object.prototype.originY = 'center';
  fabric.Object.prototype.selectable = false;
  fabric.Object.prototype.hoverCursor = 'plain';
  // =========================== #
  // ========= Helpers ========= #
  // =========================== #
  removePrivate = function(obj) {
    return _.pick(obj, (function(v, k, o) {
      return !k.startsWith('_');
    }));
  };
  angle = function(x1, y1, x2, y2) {
    var ang, x, y;
    x = x2 - x1;
    y = y2 - y1;
    if (x === 0) {
      ang = y === 0 ? 0 : y > 0 ? Math.PI / 2 : Math.PI * 3 / 2;
    } else if (y === 0) {
      ang = x > 0 ? 0 : Math.PI;
    } else {
      ang = x < 0 ? Math.atan(y / x) + Math.PI : y < 0 ? Math.atan(y / x) + 2 * Math.PI : Math.atan(y / x);
    }
    return ang + Math.PI / 2;
  };
  polarMove = function(x, y, ang, dist) {
    x += dist * Math.sin(ang);
    y -= dist * Math.cos(ang);
    return [x, y];
  };
  dist = function(o1, o2) {
    return ((o1.left - o2.left) ** 2 + (o1.top - o2.top) ** 2) ** 0.5;
  };
  redGreen = function(val) {
    if (val > 0) {
      return '#080';
    } else if (val < 0) {
      return '#b00';
    } else {
      return '#666';
    }
  };
  round = function(x) {
    return (Math.round(x * 100)) / 100;
  };
  checkObj = function(obj, keys) {
    var i, k, len;
    if (keys == null) {
      keys = Object.keys(obj);
    }
    for (i = 0, len = keys.length; i < len; i++) {
      k = keys[i];
      if (obj[k] === void 0) {
        console.log('Bad Object: ', obj);
        throw new Error(`${k} is undefined`);
      }
    }
    return obj;
  };
  KEYS = {
    up: '2',
    down: '',
    right: '3',
    left: '1',
    farright: '4',
    simulate: ' '
  }
  RIGHT_MESSAGE = '\xa0'.repeat(8) + 'Score: <span id=mouselab-score/>';
  // =============================== #
  // ========= MouselabMDP ========= #
  // =============================== #
  MouselabMDP = class MouselabMDP {
    constructor(config) {
      var blockName, centerMessage, leftMessage, lowerMessage, prompt, rightMessage, size, trial_id;
      this.runDemo = this.runDemo.bind(this);
      this.startTimer = this.startTimer.bind(this);
      //saksham
      this.trace = false;
      this.clicktrace = false;

      // Lovis
      // Enable panning during trials and demonstrations
      this.panUser=false; 
      this.panDemo=false;
      // Trial counter (format: [current_trial, total_trials])
      this.number_trials = function(){return [0,1]};
      // Maximum delay for feedback training
      this.maxDelay=1000;
      // Compute feedback on the fly instead of using a precomputed Q-table
      this.compute_binary_feedback=false;
      this.env_structure=null;
      this.compute_qs = this.compute_qs.bind(this);
      this.undo_move = true;
      this.max_q_value = 0;
      this.show_choice_options = false;
      this.dummy_tutor = false;
      this.choice = {}; // Choices available
      this.q_tolerance = 0.05 // tolerance for checking equality in q values
      this.tutor_level = function(){return 1}; // Choice tutor level
      // Partial observability 
      this.partialObservability=false;
      this.tau=null;
      this.state_dist=null; // Store mean + sigma per node
      this.state_samples={};
      this.poDemo=false;
      // Change observations between "trueReward", "lastObservation", "meanObservation", "posteriorMean"
      this.clickDisplayMode="trueReward"
      this.moveDisplayMode="trueReward"
      this.distanceCost=false
      this.distance_offset=0
      this.max_tutor_actions=30 // Cut of demonstrations and tutor sessions after this many actions in case of endless loops
      // ---------- Responding to user input ---------- #

      // Called when a valid action is initiated via a key press.
      this.handleKey = this.handleKey.bind(this);
      this.startSimulationMode = this.startSimulationMode.bind(this);
      this.endSimulationMode = this.endSimulationMode.bind(this);
      this.getOutcome = this.getOutcome.bind(this);
      this.encodeBelief = this.encodeBelief.bind(this);
      this.getReward = this.getReward.bind(this);
      this.move = this.move.bind(this);
      this.clickState = this.clickState.bind(this);
      this.showFeedback = this.showFeedback.bind(this);
      this.mouseoverState = this.mouseoverState.bind(this);
      this.mouseoutState = this.mouseoutState.bind(this);
      this.clickEdge = this.clickEdge.bind(this);
      this.mouseoverEdge = this.mouseoverEdge.bind(this);
      this.mouseoutEdge = this.mouseoutEdge.bind(this);
      this.getEdgeLabel = this.getEdgeLabel.bind(this);
      this.recordQuery = this.recordQuery.bind(this);
      // ---------- Updating state ---------- #

      // Called when the player arrives in a new state.
      this.arrive = this.arrive.bind(this);
      this.addScore = this.addScore.bind(this);
      this.resetScore = this.resetScore.bind(this);
      this.drawScore = this.drawScore.bind(this);
      // $('#mouselab-').css 'color', redGreen SCORE

      // ---------- Starting the trial ---------- #
      this.run = this.run.bind(this);
      // Draw object on the canvas.
      this.draw = this.draw.bind(this);
      // Draws the player image.
      this.initPlayer = this.initPlayer.bind(this);
      // Draws the extra image
      this.initExtraImage = this.initExtraImage.bind(this);
      // Constructs the visual display.
      this.buildMap = this.buildMap.bind(this);
      // ---------- ENDING THE TRIAL ---------- #

      // Creates a button allowing user to move to the next trial.
      this.endTrial = this.endTrial.bind(this);
      this.checkFinished = this.checkFinished.bind(this);
      // @transition=null  # function `(s0, a, s1, r) -> null` called after each transition

      // leftMessage="Round: #{TRIAL_INDEX}/#{N_TRIAL}"
      ({display: this.display, graph: this.graph, layout: this.layout, initial: this.initial, stateLabels: this.stateLabels = 'reward', stateDisplay: this.stateDisplay = 'never', revealed: this.revealed = null, stateClickCost: this.stateClickCost = 0, edgeLabels: this.edgeLabels = 'never', edgeDisplay: this.edgeDisplay = 'always', edgeClickCost: this.edgeClickCost = 0, stateRewards: this.stateRewards = null, clickDelay: this.clickDelay = 0, moveDelay: this.moveDelay = 500, clickEnergy: this.clickEnergy = 0, moveEnergy: this.moveEnergy = 0, startScore: this.startScore = 0, actions: this.actions = null, demoStates: this.demoStates = null, clicks: this.clicks = null, pid: this.pid = null, allowSimulation: this.allowSimulation = false, revealRewards: this.revealRewards = true, training: this.training = false, special: this.special = '', timeLimit: this.timeLimit = null, minTime: this.minTime = null, energyLimit: this.energyLimit = null, qs: this.qs = null, keys: this.keys = KEYS, trialIndex: this.trialIndex = TRIAL_INDEX, playerImage: this.playerImage = 'static/images/plane.png', showImage : this.showImage ,extraImage: this.extraImage = 'static/images/example1.png', size = 55, trial_id = null, blockName = 'none', prompt = '&nbsp;', leftMessage = '&nbsp;', centerMessage = '&nbsp;', rightMessage = RIGHT_MESSAGE, lowerMessage = '&nbsp;'} = config); // html display element // defines transition and reward functions // defines position of states // initial state of player // object mapping from state names to labels // one of 'never', 'hover', 'click', 'always' // subtracted from score every time a state is clicked // object mapping from edge names (s0 + '__' + s1) to labels // one of 'never', 'hover', 'click', 'always' // subtracted from score every time an edge is clicked // mapping from actions to keycodes // number of trial (starts from 1) // determines the size of states, text, etc...

      //frederic
      //this.stateRewards.push(0);
      this.termAction = `${this.stateRewards.length}`;
      disablepan = false // Lovis
      if (this.pid) {
        this.showDemo = true;
        // centerMessage = "Participant #{@pid}"
        centerMessage = 'Tutor Demonstration';
      }
      SIZE = size;
      _.extend(this, config);
      checkObj(this);
      if (this.stateLabels === 'reward') {
        this.stateLabels = this.stateRewards;
      }
      this.stateLabels[0] = '';
      leftMessage = `Round ${this.number_trials()[0] + 1}/${this.number_trials()[1]}`;

      var randomRootReward = Math.random() * (0.005 - 0.001) + 0.001
      
      // leftMessage = "Round #{@_block.trialCount + 1}/#{@_block.timeline.length}"
      this.data = {
        stateRewards: this.stateRewards,
        trial_id: trial_id,
        root_reward: randomRootReward,
        block: blockName,
        trialIndex: this.trialIndex,
        score: 0,
        simulationMode: [],
        rewards: [],
        path: [],
        rt: [],
        actions: [],
        actionTimes: [],
        queries: {
          click: {
            state: {
              'target': [],
              'time': []
            },
            edge: {
              'target': [],
              'time': []
            }
          },
          mouseover: {
            state: {
              'target': [],
              'time': []
            },
            edge: {
              'target': [],
              'time': []
            }
          },
          mouseout: {
            state: {
              'target': [],
              'time': []
            },
            edge: {
              'target': [],
              'time': []
            }
          }
        }
      };
      //console.log(this.data)
      if ($('#mouselab-msg-right').length) { // right message already exists
        this.leftMessage = $('#mouselab-msg-left');
        this.leftMessage.html(leftMessage);
        this.centerMessage = $('#mouselab-msg-center');
        this.centerMessage.html(centerMessage);
        this.rightMessage = $('#mouselab-msg-right');
        this.rightMessage.html(rightMessage);
        this.stage = $('#mouselab-stage');
        this.prompt = $('#mouselab-prompt');
        this.prompt.html(prompt);
      } else {
        // @canvasElement = $('#mouselab-canvas')
        // @lowerMessage = $('#mouselab-msg-bottom')
        //this.display.empty();
        // @display.css 'width', '1000px'

        // leftMessage = "Round: #{@trialIndex + 1}/#{@_block.timeline.length}"
        this.leftMessage = $('<div>', {
          id: 'mouselab-msg-left',
          class: 'mouselab-header',
          html: leftMessage
        }).appendTo(this.display);
        this.centerMessage = $('<div>', {
          id: 'mouselab-msg-center',
          class: 'mouselab-header',
          html: centerMessage
        }).appendTo(this.display);
        this.rightMessage = $('<div>', {
          id: 'mouselab-msg-right',
          class: 'mouselab-header',
          html: rightMessage
        }).appendTo(this.display);
        if (prompt !== null) {
          this.prompt = $('<div>', {
            id: 'mouselab-prompt',
            class: 'mouselab-prompt',
            html: prompt
          }).appendTo(this.display);
        }
        this.stage = $('<div>', {
          id: 'mouselab-stage'
        }).appendTo(this.display);
        if (this.timeLimit) {
          TIME_LEFT = this.timeLimit;
        }
        this.addScore(this.startScore);
      }
      // -----------------------------
      this.ExtracanvasElement = $('<canvas>', {
        id: 'mouselab-canvas2'
      }).attr({
        width: 565,
        height: 665
      }).appendTo(this.stage);
      this.canvasElement = $('<canvas>', {
        id: 'mouselab-canvas'
      }).attr({
        width: 500,
        height: 500
      }).appendTo(this.stage);
      this.lowerMessage = $('<div>', {
        id: 'mouselab-msg-bottom',
        class: 'mouselab-msg-bottom',
        html: lowerMessage || '&nbsp'
      }).appendTo(this.stage);
      this.waitMessage = $('<div>', {
        id: 'mouselab-wait-msg',
        class: 'mouselab-msg-bottom'
      // html: """Please wait <span id='mdp-time'></span> seconds"""
      }).appendTo(this.display);
      this.waitMessage.hide();
      this.defaultLowerMessage = lowerMessage;
      // feedback element
      $('#jspsych-target').append("<div id=\"mdp-feedback\" class=\"modal\">\n  <div id=\"mdp-feedback-content\" class=\"modal-content\">\n    <h3>Default</h3>\n  </div>\n</div>");
      mdp = this;
      //LOG_INFO('new MouselabMDP', this);
      this.invKeys = _.invert(this.keys);
      this.resetScore();
      this.freeze = false;
      this.lowerMessage.css('color', '#000');

      // Lovis
      // Init PO state for PO feedback
      if(this.partialObservability){
        this.state_dist = JSON.parse(JSON.stringify(this.env_structure["init"]))
        this.minimum_clicks = this.n_actions.length - 1
        //console.log("Init state dist", this.state_dist)
        if(this.dummy_tutor){
          this.reward_groups = JSON.parse(JSON.stringify(this.env_structure["reward_groups"]))
        }
      }
      if(this.show_choice_options){
        this.data["choice-feedback"] = []
        this.data["tutor-level"] = this.tutor_level()
        //console.log("Trial tutor level", this.tutor_level())
      }
    }

    async runPODemo() {
      document.getElementById("mouselab-canvas").style["border"] = "5px solid rgb(128, 0, 0)"
      this.timeLeft = 1;
      console.log('runDemo');
      await sleep(600);

      // while q > 0
      var terminate = false
      while(!terminate){
        var qs = await this.compute_qs()
        //console.log(qs)
        var v = _.max(qs);
        var action_choices = []
        for(var action of Object.keys(qs)){
          if(qs[action] == v){
            action_choices.push(action)
          }
        }
        var action = _.sample(action_choices)
        if(action != this.termAction && this.data.queries.click.state.target.length <this.max_tutor_actions){
          await sleep(1200);
          await this.clickState(this.states[action], action, true, true); // TODO
          this.canvas.renderAll();
        }
        else{
          terminate = true
        }        
      }
      
      // find optimal path
      var optimal_path = null
      var optimal_path_value = null
      for(var path of this.env_structure["paths"]){
        var path_reward = 0;
        for(var node of path){
          path_reward += this.state_dist[node][0]
        }
        if(optimal_path == null || path_reward > optimal_path_value){
          optimal_path_value = path_reward
          optimal_path = path
        }
      }
      //TODO
      //Find movement actions for optimal path
      var actions = []
      var s0 = parseInt(this.initial)
      for(var node of optimal_path){
        var s1 = node

        this.graph[s0]
        for(var action of Object.keys(this.graph[s0])){
          if(this.graph[s0][action][1] == node.toString()){
            s0 = s1
            actions.push(action)
            break
          }
        }
      }
      //console.log(optimal_path)
      //console.log(actions)
      // move along optimal path
      if (actions != null) {
        var ref1 = actions;
        var results = [];
        for (var j = 0, len1 = ref1.length; j < len1; j++) {
          var a = ref1[j];
          if(j<len1-1){
            await sleep(800);
          }
          var s = _.last(this.data.path);
          results.push(await this.handleKey(s, a)); 
        }
        return results;
      }
    }

    async runDummyPODemo() {
      document.getElementById("mouselab-canvas").style["border"] = "5px solid rgb(128, 0, 0)"
      this.timeLeft = 1;
      console.log('runDummyDemo');
      await sleep(600);

      for(var i=0; i<this.minimum_clicks; i++){
        var selected_choices = this.generate_dummy_actions()
        var action = _.sample(selected_choices)
        await sleep(1200);
        await this.clickState(this.states[action], action, true, true); // TODO
        this.canvas.renderAll();
      }
      
      // Select random path
      var path = _.sample(this.env_structure["paths"])
      
      // Find movement actions for path
      var actions = []
      var s0 = parseInt(this.initial)
      for(var node of path){
        var s1 = node

        this.graph[s0]
        for(var action of Object.keys(this.graph[s0])){
          if(this.graph[s0][action][1] == node.toString()){
            s0 = s1
            actions.push(action)
            break
          }
        }
      }

      // Move along path
      if (actions != null) {
        var ref1 = actions;
        var results = [];
        for (var j = 0, len1 = ref1.length; j < len1; j++) {
          var a = ref1[j];
          await sleep(800);
          var s = _.last(this.data.path);
          results.push(await this.handleKey(s, a));
          //results.push(res); 
        }
        return results;
      }
    }

    async runDemo() {
      var a, c, i, j, l, len, len1, len2, ref, ref1, ref2, results, results1, s, s1;
      this.timeLeft = 1;
      console.log('runDemo');
      ref = this.clicks;
      await sleep(600);
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        await sleep(1200);
        if(c == '404'){ //frederic
          mdp.endTrial(false);
          return;
        }
        this.clickState(this.states[c], c, true, true); // TODO
        this.canvas.renderAll();
      }
      if (this.actions != null) {
        ref1 = this.actions;
        results = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          a = ref1[j];
          await sleep(800);
          s = _.last(this.data.path);
          results.push(this.handleKey(s, a)); 
        }
        return results;
      } else {
        ref2 = this.demoStates;
        results1 = [];
        for (l = 0, len2 = ref2.length; l < len2; l++) {
          s1 = ref2[l];
          await sleep(800);
          this.move(s, null, s1);
          results1.push(s = s1);
        }
        return results1;
      }
    }

    startTimer() {
      var interval;
      this.timeLeft = this.minTime;
      this.waitMessage.html(`<br> Please wait ${this.timeLeft} seconds`);
      interval = ifvisible.onEvery(1, () => {
        if (this.freeze) {
          return;
        }
        this.timeLeft -= 1;
        this.waitMessage.html(`<br> Please wait ${this.timeLeft} seconds`);
        // $('#mdp-time').html @timeLeft
        // $('#mdp-time').css 'color', (redGreen (-@timeLeft + .1))  # red if > 0
        if (this.timeLeft === 0) {
          interval.stop();
          return this.checkFinished();
        }
      });
      $('#mdp-time').html(this.timeLeft);
      return $('#mdp-time').css('color', redGreen(-this.timeLeft + .1));
    }

    endBlock() {
      this.blockOver = true;
      jsPsych.pluginAPI.cancelAllKeyboardResponses();
      return this.keyListener = jsPsych.pluginAPI.getKeyboardResponse({
        valid_responses: [' '],
        rt_method: 'performance',
        persist: false,
        allow_held_key: false,
        callback_function: (info) => {
          jsPsych.finishTrial(this.data);
          this.display.empty();
          return jsPsych.endCurrentTimeline();
        }
      });
    }

    handleKey(s0, a) {
      var _, s1;
      LOG_DEBUG('handleKey', s0, a);
      if (a === 'simulate') {
        if (this.simulationMode) {
          return this.endSimulationMode();
        } else {
          return this.startSimulationMode();
        }
      } else {
        if (!this.simulationMode) {
          this.allowSimulation = false;
          if(!this.showDemo && !this.poDemo){
            this.moveInstruction =  `<br>Planning:<br>Clicking on a node reveals its value for a $${this.stateClickCost} fee.<br><br>Moving:<br>Press the number keys 1 to 4 to move to the next node as indicated by the numbers on the edges.<br>Try using the number keys on top of your keyboard if the numpad keys don't work.<br><br>Camera:<br>Use the mouse to drag the camera and the mousewheel to zoom in and out.<br>Press the reset position button to reset the camera.`;
          }
          else{
            this.moveInstruction = "<br>Please do not leave the current tab or the window during the demonstration.";
          }
          if (this.defaultLowerMessage) {
            this.lowerMessage.html(this.moveInstruction);
            this.lowerMessage.css('color', '#000');
          }
        }
        this.data.actions.push(a);
        this.data.simulationMode.push(this.simulationMode);
        this.data.actionTimes.push(Date.now() - this.initTime);
        [_, s1] = this.graph[s0][a];
        // LOG_DEBUG "#{s0}, #{a} -> #{r}, #{s1}"

        // Lovis
        if(this.panDemo){
          var node = this.states[parseInt(s1)]
          // Animate X
          fabric.util.animate({
            startValue: -this.canvas["viewportTransform"][4],
            endValue: -0.5*this.canvas.getWidth()+node["left"],
            duration: 500,
            byvalue: 1,
            onChange: (pan) => {
              this.canvas.absolutePan({ x: pan, y: -this.canvas["viewportTransform"][5]});
              this.canvas.renderAll();
            },
            onComplete: () => {
                this.canvas.renderAll();
            }
          });
          // Animate Y
          fabric.util.animate({
            startValue: -this.canvas["viewportTransform"][5],
            endValue: -0.5*this.canvas.getHeight()+node["top"],
            duration: 500,
            byvalue: 1,
            onChange: (pan) => {
              this.canvas.absolutePan({ x: -this.canvas["viewportTransform"][4], y: pan});
              this.canvas.renderAll();
            },
            onComplete: () => {
                this.canvas.renderAll();
            }
          });
        }
        return this.move(s0, a, s1);
      }
    }

    startSimulationMode() {
      this.simulationMode = true;
      this.player.set('top', this.states[this.initial].top - 20).set('left', this.states[this.initial].left);
      this.player.set('opacity', 0.4);
      this.canvas.renderAll();
      this.extra_canvas.renderAll();
      this.arrive(this.initial);
      // @centerMessage.html 'Ghost Score: <span id=mouselab-ghost-score/>'
      this.rightMessage.html('Ghost Score: <span id=mouselab-score/>');
      this.resetScore();
      this.drawScore(this.data.score);
      return this.lowerMessage.html("<b>👻 Ghost Mode 👻</b>\n<br>\nPress <code>space</code> to return to your corporeal form.");
    }

    endSimulationMode() {
      this.simulationMode = false;
      this.player.set('top', this.states[this.initial].top).set('left', this.states[this.initial].left);
      this.player.set('opacity', 1);
      this.canvas.renderAll();
      this.extra_canvas.renderAll();
      this.arrive(this.initial);
      this.centerMessage.html('');
      this.rightMessage.html(RIGHT_MESSAGE);
      this.resetScore();
      return this.lowerMessage.html(this.defaultLowerMessage);
    }

    getOutcome(s0, a) {
      var r, s1;
      LOG_DEBUG(`getOutcome ${s0}, ${a}`);
      [s1, r] = this.graph[s0][a];
      if (this.stateRewards != null) {
        r = this.stateRewards[s1];
      }
      return [r, s1];
    }

    encodeBelief() {
      var b;
      b = _.values(this.states).map((g) => {
        return g.label.text || '_';
      });
      b[0] = 0; // first state is known to be 0
      return b.join(' ');
    }

    getReward(s0, a, s1) {
      if (this.stateRewards != null) {
        return(this.getStateDisplay(s1, this.moveDisplayMode))
        //return this.stateRewards[s1];
      } else {
        return this.graph[s0][a];
      }
    }

    async move(s0, a, s1) {
      var nClick, newTop, notEnoughClicks, r, s1g;
      if(this.clicktrace){
        nClick = this.data.queries.click.state.target.length;
        console.log(`nclick ${nClick}`);
        notEnoughClicks = nClick < 1;
        console.log(`notEnoughClicks ${notEnoughClicks}`);
        if (notEnoughClicks) {
          this.lowerMessage.html('<br><b>Inspect at least one node before moving!</b>');
          this.lowerMessage.css('color', '#FC4754');
          await sleep(1500);
          this.moveInstructionClick = `<br>Clicking on a node to reveals its value for a $${this.stateClickCost}.<br><br>To move above:<br>Press 1: move to left most node  or if only possible path from current node<br>Press 2: move to second node from left from current node<br>Press 3: move to third node from left from current node <br> Press 4: move to fourth node from left from current node<br>Try using the keys on the top of your keyboard if the numpad keys don't work.`;
          this.lowerMessage.html(this.moveInstructionClick);
          this.lowerMessage.css('color', '#000');
          this.arrive(s0, 'repeat');
          return;
        }
      }
      if(this.trace){
        if (this.revealed.indexOf(parseInt(s1)) === -1){
          this.moveInstructionTrace = '<b>Follow the revealed path by using the arrow keys</b><br>To move above:<br> Press 1: move to left most node<br>Press 2: move to centre-left/centre node<br>Press 3: move to centre-right node <br> Press 4: move to right most node<br> Try using the keys on the top of your keyboard if the numpad keys don\'t work.';
          this.lowerMessage.html("<b>Wrong key!. </b>");
          this.lowerMessage.css('color', '#FC4754');
          await sleep(1500);
          this.lowerMessage.html(this.moveInstruction);
          this.lowerMessage.css('color', '#000');
          this.arrive(s0, 'repeat');
          return;
        }
      }
      if (!this.moved) {
        var delay = await this.showFeedback(this.termAction);
        if(this.dummy_tutor && this.data.queries.click.state.target.length < this.minimum_clicks){
          this.reset_choice_highlight()
          await this.generate_choice()
          return this.arrive(this.initial);
        }
        // Prevent early termination
        if(this.partialObservability && delay > 0 && this.data.queries.click.state.target.length < this.max_tutor_actions){ //this.undo_move && delay > 0){
          this.reset_choice_highlight()
          await this.generate_choice()
          return this.arrive(this.initial);
        }
      }
      this.moved = true;
      if (this.freeze) {
        LOG_INFO('freeze!');
        this.arrive(s0, 'repeat');
        return;
      }
      // nClick = this.data.queries.click.state.target.length;
      // notEnoughClicks = (this.special.startsWith('trainClick')) && nClick < 3;
      // if (notEnoughClicks) {
      //   this.lowerMessage.html('<b>Inspect at least three nodes before moving!</b>');
      //   this.lowerMessage.css('color', '#FC4754');
      //   this.special = 'trainClickBlock';
      //   this.arrive(s0, 'repeat');
      //   return;
      // }
      r = this.getReward(s0, a, s1);
      LOG_DEBUG(`move ${s0}, ${s1}, ${r}`);
      s1g = this.states[s1];
      this.freeze = true;
      newTop = this.simulationMode ? s1g.top - 20 : s1g.top + TOP_ADJUST;
      // return this.player.animate({
      //   left: s1g.left,
      //   top: newTop
      // }, {
      //   duration: this.moveDelay,
      //   onChange: this.canvas.renderAll.bind(this.canvas),
      //   onComplete: () => {
      //     this.data.rewards.push(r);
      //     this.addScore(r);
      //     return this.arrive(s1);
      //   }
      // });
      return new Promise((resolve) => {
        this.player.animate({
          left: s1g.left,
          top: newTop
        }, {
          duration: this.moveDelay,
          onChange: this.canvas.renderAll.bind(this.canvas),
          onComplete: () => {
            this.data.rewards.push(r);
            this.addScore(r);
            resolve(this.arrive(s1));
          }
        });
      })
    }

    async clickState(g, s, highlight=false) {
      // Pan canvas - Lovis
      if(this.panDemo){
        // Animate X
        fabric.util.animate({
          startValue: -this.canvas["viewportTransform"][4],
          endValue: -0.5*this.canvas.getWidth()+g["left"],
          duration: 500,
          byvalue: 1,
          onChange: (pan) => {
            this.canvas.absolutePan({ x: pan, y: -this.canvas["viewportTransform"][5]});
            this.canvas.renderAll();
          },
          onComplete: () => {
              this.canvas.renderAll();
          }
        });
        // Animate Y
        fabric.util.animate({
          startValue: -this.canvas["viewportTransform"][5],
          endValue: -0.5*this.canvas.getHeight()+g["top"],
          duration: 500,
          byvalue: 1,
          onChange: (pan) => {
            this.canvas.absolutePan({ x: -this.canvas["viewportTransform"][4], y: pan});
            this.canvas.renderAll();
          },
          onComplete: () => {
              this.canvas.renderAll();
          }
        });
        await sleep(600);
      }
      var r;
      LOG_INFO(`clickState1 ${s}`);
      if (this.moved) {
        this.lowerMessage.html("<br><b>You can't use the node inspector after moving!</b>");
        this.lowerMessage.css('color', '#FC4754');
        await sleep(1500);
        this.lowerMessage.html(this.moveInstruction);
        this.lowerMessage.css('color', '#000');
        return;
      }
      if (this.complete || (`${s}` === `${this.initial}`) || this.freeze) {
        return;
      }
      if (this.special === 'trainClickBlock' && this.data.queries.click.state.target.length === 2) {
        this.lowerMessage.html('<b>Nice job! You can click on more nodes or start moving.</b>');
        this.lowerMessage.css('color', '#000');
      }
      // Lovis PO click
      if(this.stateLabels && this.stateDisplay === 'click' && this.partialObservability){
        // If choice tutor is used and an incorrect state is clicked:
        if(this.show_choice_options && !(_.isEmpty(this.choice)) && !(s in this.choice)){
          if(this.dummy_tutor){
            if(this.data.queries.click.state.target.length < this.minimum_clicks){
              var msg = "Choose one of the highlighted blue nodes.";
            }
            else{
              var msg = "Start moving now.";
            }
          }
          else{
            var msg = "Choose one of the highlighted blue nodes<br>or start moving."
          };
          this.prompt.html(`<div align='center' style='padding-top:60px; color:#ff0000; font-weight:bold; font-size:18pt'>\n${msg}\n</div>`);
        }
        else{
          var delay = await this.showFeedback(s); // Note: this must be called before g.setLabel r
          //console.log(delay)
          if(this.undo_move && delay > 0){
            return;
          }
          if(g.label){
            this.canvas.remove(g.label)
          }
          if(this.samples[s].length>0){
            this.addScore(-this.stateClickCost);
            this.recordQuery('click', 'state', s);
            var sample = this.samples[s].shift();
            // Update state
            if(s != this.termAction){
              var new_state = this.state_dist[s]
              var mean = new_state[0]
              var sigma = new_state[1]
              var tau_old = 1 / (sigma ** 2)
              var tau_new = tau_old + this.tau 
              var mean_new = ((mean * tau_old) + this.tau * sample) / tau_new
              var sigma_new = 1 / Math.sqrt(tau_new)
              //console.log(`Observation ${sample}, old mean: ${mean+ ", " + tau_old}, new mean: ${mean_new + ", " + tau_new}`)
              this.state_dist[s] = [mean_new, sigma_new]
              //console.log("Updated node", s, "with mean", mean_new, "sigma", sigma_new, "and sample", sample)
            }
            if(s in this.state_samples){
              this.state_samples[s].push(sample)
            }
            else{
              this.state_samples[s] = [sample]
            }
            var mean = round(this.state_samples[s].reduce((a,b) => a + b, 0) / this.state_samples[s].length)
            g.setLabel(this.getStateDisplay(s, this.clickDisplayMode))
            if(highlight) g.animateClick();
            //g.setLabel(mean)
            //g.setLabel(sample);
          }
          else{
            g.setLabel(this.getStateDisplay(s, this.clickDisplayMode))
            if(highlight) g.animateClick();
            //this.freeze = true
            this.prompt.html(`<div align='center' style='padding-top:60px; color:#FF0000; font-weight:bold; font-size:18pt'>\nMaximum number of clicks for this node reached.\n</div>`);
            await sleep(1500);
            this.prompt.html("");
            //this.freeze = false
          }
          // Lovis: Display options for next click
          if(this.show_choice_options){
            this.reset_choice_highlight()
            if(!this.dummy_tutor){
              await this.generate_choice()
            }
            else{
              await this.generate_dummy_choice()
            }
          }
        }
        return this.canvas.renderAll();
      }
      // Original click
      else if (this.stateLabels && this.stateDisplay === 'click' && !g.label.text) {
        await this.showFeedback(s); // Note: this must be called before g.setLabel r
        this.addScore(-this.stateClickCost);
        this.recordQuery('click', 'state', s);
        r = this.stateLabels[s];
        if (this.clickDelay) {
          this.freeze = true;
          g.setLabel('...');
          await sleep(this.clickDelay); //Changed this
          this.freeze = false;
        }
        g.setLabel(r);
        if(highlight) g.animateClick();
        return this.canvas.renderAll();
      }
    }

    // Lovis TODO
    // Runs BMPS to compute binary feedback on the fly
    async compute_qs(){

      let deepcopy = (array) => {
        // Ugly hack, maybe find a better way later
        return JSON.parse(JSON.stringify(array))
      }

      if(!this.partialObservability){
        // Standard BMPS features without partial observability
        
        let expected_value = (node) => {
          var reward = 0
          for(var outcome of node){
            var p = outcome[0]
            var r = outcome[1]
            reward += p*r
          }
          return reward
        }

        let get_obs_tree = (state, obs) => {
          var obs_state = []
          for(var i=0; i<state.length; i++){
            if(obs.indexOf(i) >= 0){
              obs_state.push(deepcopy(state[i]))
            }
            else{
              obs_state.push([[1, expected_value(state[i])]])
            }
          }
          return obs_state
        }

        let reduce = (state, op, i, j) => {
          var new_state = []
          for(var k=0; k<state.length; k++){
            if(k!=j){
              new_state.push(deepcopy(state[k]))
            }
          }
          var added_outcome = {}
          var encountered_outcomes = []
          for(var k=0; k<state[i].length; k++){
            var p_i = state[i][k][0]
            var v_i = state[i][k][1]
            for(var l=0; l<state[j].length; l++){
              var p_j = state[j][l][0]
              var v_j = state[j][l][1]

              var p = p_i * p_j
              if(op=="add"){
                var v = (v_i + v_j).toString()
              }
              else if(op=="mul"){
                var v = (Math.max(v_i, v_j)).toString()
              }
              else{
                console.log("UNKOWN OP")
              }
              if(encountered_outcomes.indexOf(v) == -1){
                encountered_outcomes.push(v)
              }
              if(v in added_outcome){
                added_outcome[v] += p
              }
              else{
                added_outcome[v] = p
              }
            }
          }
          var i_value = []
          for(var v of encountered_outcomes){
            i_value.push([added_outcome[v], parseFloat(v)])
          }
          new_state[i] = i_value
          return new_state
        }

        let value_after_observe = obs_tree => {
          for(var op of this.env_structure.operations){
            obs_tree = reduce(obs_tree, op[0], op[1], op[2])
          }
          return obs_tree
        }

        // Get current state
        var stateValue;
        stateValue = _.values(this.states).map((g) => {
          var parsed = parseInt(g.label.text)
          if(isNaN(parsed)){
            return '_'
          }
          else{
            return parsed
          }
          //return parseInt(g.label.text) || '_'; // Bug: This returns "_" for "0"
        });
        stateValue[0] = 0; // Root node
        var state = deepcopy(stateValue)
        var available_actions = []
        for(var i=0; i<stateValue.length; i++){
          if(stateValue[i] == "_"){
            state[i] = deepcopy(this.env_structure.init[i.toString()])
            available_actions.push(i)
          }
          else{
            state[i] = [[1, stateValue[i]]]
          }
        }
        available_actions.push(stateValue.length)
        //console.log("State", state)
        //console.log("Available actions", available_actions)
        
        // Get term reward
        var path_rewards = []
        for(var path of this.env_structure.paths){
          var path_reward = 0
          for(var node of path){
            path_reward += expected_value(state[node])
          }
          path_rewards.push(path_reward)
        }
        var term_reward = Math.max.apply(null, path_rewards);
        //console.log("Term reward", term_reward)

        // Get VPI
        var obs = [...Array(state.length).keys()]
        var obs_tree = get_obs_tree(state, obs)
        var root = value_after_observe(obs_tree)
        var vpi = expected_value(root[0]) - term_reward

        // Get Myopic and VPI action
        var voc = {}
        for(var i=0; i<available_actions.length; i++){
          var action = available_actions[i]
          // Myopic
          if(action != parseInt(this.env_structure.term_action)){
            var obs = [action]
            var obs_tree = get_obs_tree(state, obs)
            var root = value_after_observe(obs_tree)
            var mvoc = expected_value(root[0]) - term_reward
          }
          else{
            var mvoc = 0
          }

          // VPI action
          if(action != parseInt(this.env_structure.term_action)){
            var obs = this.env_structure.vpi_sets[action.toString()]
            var obs_tree = get_obs_tree(state, obs)
            var root = value_after_observe(obs_tree)
            var vpia = expected_value(root[0]) - term_reward
          }
          else{
            var vpia = 0
          }

          // Cost
          if(action != parseInt(this.env_structure.term_action)){
            var cost = -this.stateClickCost
          }
          else{
            var cost = 0
          }
          
          var w = this.env_structure.weights
          voc[action.toString()] = w["w1"] * mvoc + w["w2"] * vpi + w["w3"] * vpia + w["w4"] * cost
        }
      }
      else{
        // Partially observable myopic VOC calculation

        let cdf = (mean, sigma, to) => {
          // https://stackoverflow.com/questions/5259421/cumulative-distribution-function-in-javascript
          var z = (to-mean)/Math.sqrt(2*sigma*sigma);
          var t = 1/(1+0.3275911*Math.abs(z));
          var a1 =  0.254829592;
          var a2 = -0.284496736;
          var a3 =  1.421413741;
          var a4 = -1.453152027;
          var a5 =  1.061405429;
          var erf = 1-(((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-z*z);
          var sign = 1;
          if(z < 0)
          {
              sign = -1;
          }
          return (1/2)*(1+sign*erf);
        }

        let pdf = (mean, sigma, to) => {
          // https://github.com/errcw/gaussian/blob/master/lib/gaussian.js
          var m = sigma * Math.sqrt(2 * Math.PI);
          var e = Math.exp(-Math.pow(to - mean, 2) / (2 * sigma * sigma));
          return e / m;
        }

        let expect_lower = (mean, sigma, T) => {
          var t = (T-mean)/sigma
          if(cdf(0,1,t) < 0.0000001){
            return NaN
          }
          return mean - sigma*pdf(0,1,t)/cdf(0,1,t)
        }

        let expect_higher = (mean, sigma, T) => {
          var t = (T-mean)/sigma
          if(Math.abs(cdf(0,1,t)-1) < 0.0000001){
            return NaN
          }
          return mean + sigma*pdf(0,1,t)/(1-cdf(0,1,t))
        }
        
        let myopic_voc = (a) => {
          var eps = 1e-8
          // Find path rewards of the action and alternative best path
          var action_path_reward = null;
          var alternative_path_reward = null;
          for(path of this.env_structure["paths"]){
            var path_reward = 0;
            var found = false;
            for(node of path){
              if(node == a){
                found = true;
              }
              path_reward += this.state_dist[node][0]
            }
            if(found){ // action_path
              if(action_path_reward == null || path_reward>action_path_reward){
                action_path_reward = path_reward
              }
            }
            else { // alternative_path
              if(alternative_path_reward == null || path_reward>alternative_path_reward){
                alternative_path_reward = path_reward
              }
            }
          }
          
          // Filter out edge cases where no alternative path exists - observing these nodes has no value
          if(action_path_reward == null || alternative_path_reward == null){
            return -this.stateClickCost
          }

          var action_path_without_node = action_path_reward - this.state_dist[a][0]

          var value = this.state_dist[a][0]
          var sigma = this.state_dist[a][1]
          var tau_old = 1 / (sigma ** 2)
          var tau_new = tau_old + this.tau
          var sample_sigma = 1 / Math.sqrt(this.tau)

          // Sample threshold that leads to a different optimal path
          var threshold = (((alternative_path_reward - action_path_without_node)*tau_new) - (value * tau_old)) / this.tau
          
          // The path leading through the selected node is optimal
          if(action_path_reward > alternative_path_reward){
            // Probability of sampling worse than the threshold value
            var p_being_worse = cdf(value, sample_sigma, threshold)
            // Expected sample value given that it is below the threshold
            var expected_lower = expect_lower(value, sample_sigma, threshold)
            // Update the node distribution with the expected sample
            var updated_node = ((value * tau_old) + this.tau * expected_lower) / tau_new
            // Gain = alternative path minus the new node path weighted by probability
            var voc = (alternative_path_reward - action_path_without_node - updated_node) * p_being_worse
            // if(p_being_worse < eps || expected_lower == NaN){
            //   voc = 0
            // }
          }
          // The path leading through the selected node is not optimal
          else{
            // Probability of sampling higher than the threshold
            var p_being_better = 1 - cdf(value, sample_sigma, threshold)
            // Expected sample value given that it is above the threshold
            var expected_higher = expect_higher(value, sample_sigma, threshold)
            // Update the node distribution with the expected sample
            var updated_node = ((value * tau_old) + this.tau * expected_higher) / tau_new
            // Gain = new node path minus the old path weighted by probability
            var voc = (action_path_without_node + updated_node - alternative_path_reward) * p_being_better
            // if(p_being_better < eps || expected_higher == NaN){
            //     voc = 0
            // }
          }
          if(isNaN(voc)){
            voc = 0
          }
          return voc
        }

        var available_actions = []
        for(action of Object.keys(this.samples)){
          if(this.samples[action].length>0){
            available_actions.push(parseInt(action))
          }
        }
        
        voc = {}
        for(action of available_actions){
          if(!this.distanceCost || this.data.queries.click.state.target.length==0){
            voc[action] = myopic_voc(action) - this.stateClickCost
            //console.log("No distance cost", this.data.queries.click)
          }
          else{
            var distance_coef=0.0996032
            var no_repeat_coef=0.94944094
            var intercept=0.66353316
            var bonus_per_point=0.0042 // Pilot 3 cond 1 mean
            var hourly_wage=5 // Minimum hourly pay on Prolific
            //var distance_offset = 0.26

            var prev_click = parseInt(this.data.queries.click.state.target[this.data.queries.click.state.target.length - 1])
            var distance = Math.sqrt((this.layout[prev_click][0]-this.layout[action][0])**2 + (this.layout[prev_click][1]-this.layout[action][1])**2)
            var distance_scaling = (hourly_wage/60/60)/bonus_per_point
            var time = intercept + distance * distance_coef 
            if(distance>0){
              time += no_repeat_coef
            }
            var distance_cost = distance_scaling * time
            //console.log(parseInt(prev_click), action, distance_scaling, distance, distance_cost, this.distance_offset)
            voc[action] = myopic_voc(action) - (this.stateClickCost + distance_cost) + this.distance_offset
          }
          
        }
        voc[this.termAction] = 0
      }
      
      //console.log(voc)
      
      return voc
    }

    // Lovis: Changed this to allow to compute feedback on the fly. Also changed feedback for not terminating (I doubt this has ever worked)
    async showFeedback(action) {
      if(this.show_choice_options){
        return this.show_choice_feedback(action)
      }
      var a, defaultMessage, delay, i, j, len, len1, loss, msg, optimal, q, qs, ref, ref1, s, strictness, v, term_mistake, tolerance;
      tolerance = this.q_tolerance      
      if (this.show_feedback) {
        // if(this.show_choice_options){
        //   return //TODO
        // }
        if(!this.compute_binary_feedback && !this.show_choice_options){
          qs = this.qs[this.encodeBelief()];
        }
        else{
          qs = await this.compute_qs()
        }
        v = _.max(qs);
        if(v>this.max_q_value){
          this.max_q_value = v;
        }
        optimal = (function() {
          var results;
          results = [];
          for (a in qs) {
            q = qs[a];
            if (q >= 0 && Math.abs(v - q) < tolerance) {
              results.push(a);
            }
          }
          return results;
        })();
        //if action in optimal
        //     return
        this.freeze = true;
        if(!this.compute_binary_feedback){
          strictness = 1;
          loss = Math.abs(v - qs[action]);
          if (loss >= 0 + tolerance || qs[action] < 0) {
            delay = 2 + Math.round(strictness * loss);
          } else {
            delay = 0;
          }
          delay = Math.min(delay, this.maxDelay)
        }
        else {
          loss = Math.abs(v - qs[action]);
          if(loss >= tolerance || qs[action] < 0){
            delay = 4
            //if(optimal.indexOf(this.env_structure.term_action.toString()) >= 0 || action == this.env_structure.term_action){
            if(action == this.env_structure.term_action){
              // Calculate delta between expected term reward and 
              // var path_rewards = []
              // var true_rewards = []
              // for(var path of this.env_structure.paths){
              //   var path_reward = 0
              //   var true_reward = 0
              //   for(var node of path){
              //     path_reward += this.state_dist[node][0]
              //     true_reward += this.stateRewards[node]
              //   }
              //   path_rewards.push(path_reward)
              //   true_rewards.push(true_reward)
              // }
              // var term_reward = Math.max.apply(null, path_rewards);
              // var max_path = Math.max.apply(null, true_rewards);
              // console.log(term_reward)
              // console.log(max_path)
              // var scaled = (40 / max_path)*(max_path - term_reward)//(term_reward / true_reward) * (40 - 3) + 3
              var scaled = (40 / this.max_q_value)*v//(this.max_q_value - (this.max_q_value - v)) // scale delay based on best action observed in the environment
              delay = Math.round(Math.min(Math.max(4, scaled), 40)) // Clamp between 4 and 40
              //console.log(this.max_q_value, v, scaled, delay)

              // Alternative delay based on expected term reward
              // Get term reward
              // var path_rewards = []
              // for(var path of this.env_structure.paths){
              //   var path_reward = 0
              //   for(var node of path){
              //     path_reward += this.state_dist[node][0] // TODO this will only work for PO envs for now
              //   }
              //   path_rewards.push(path_reward)
              // }
              // var term_reward = Math.max.apply(null, path_rewards);
              // var exp_scaled = (40 / this.expReward)*(this.expReward - term_reward)
              // var delay_term = Math.round(Math.min(Math.max(3, exp_scaled), 40))
              // console.log("EXP reward", this.expReward, term_reward, delay_term)
            }
          } else {
            delay = 0;
          }
        }
      } else {
        return;
      }
      if (this.show_feedback) {
        defaultMessage = "";
        this.prompt.html(defaultMessage);
        //oldFeedbackMessage = @prompt.html()
        if (loss < tolerance && qs[action] >= 0){ //loss === 0) {
          this.prompt.html("<div align='center' style='padding-top:60px; color:#008800; font-weight:bold; font-size:18pt'>\nGood job!\n</div>");
        } else {
          if ((ref = this.termAction, indexOf.call(optimal, ref) >= 0)) {
            msg = "You shouldn't have inspected any more nodes.";
            msg += `<br> Please wait ${delay} seconds.`;
            this.prompt.html(`<div align='center' style='padding-top:60px; color:#FF0000; font-weight:bold; font-size:18pt'>\n${msg}\n</div>`);
            await sleep(delay * 1000);
            this.prompt.html(defaultMessage);
          } else {
            msg = "You should have inspected one of the highlighted nodes.";
            for (i = 0, len = optimal.length; i < len; i++) {
              a = optimal[i];
              this.states[a].circle.set('fill', '#49f');
              this.canvas.renderAll();
            }
            msg += `<br> Please wait ${delay} seconds.`;
            this.prompt.html(`<div align='center' style='padding-top:60px; color:#FF0000; font-weight:bold; font-size:18pt'>\n${msg}\n</div>`);
            // @freeze = true
            // $('#mdp-feedback').show()
            // $('#mdp-feedback-content')
            //   .html msg
            // $('#mdp-feedback').hide()
            await sleep(delay * 1000);
            // Reset.
            this.prompt.html(defaultMessage);
          }
        }
      } else {
        console.log('no');
      }
      this.freeze = false;
      if (ref1 = this.termAction, indexOf.call(optimal, ref1) < 0) {
        for (j = 0, len1 = optimal.length; j < len1; j++) {
          s = optimal[j];
          this.states[s].circle.set('fill', '#bbb');
        }
        this.canvas.renderAll()
      }
      return delay
    }

    async show_choice_feedback(action){
      var a, defaultMessage, delay, i, j, len, len1, loss, msg, optimal, q, qs, ref, ref1, s, strictness, v, term_mistake, tolerance;
      tolerance = this.q_tolerance
      if (this.show_feedback) {
        qs = this.choice
        v = _.max(qs);
        if(v>this.max_q_value){
          this.max_q_value = v;
        }
        optimal = (function() {
          var results;
          results = [];
          for (a in qs) {
            q = qs[a];
            if (q >= 0 && Math.abs(v - q) < tolerance) {
              results.push(a);
            }
          }
          return results;
        })();
        //if action in optimal
        //     return
        this.freeze = true;
        loss = Math.abs(v - qs[action]);
        if(loss >= tolerance || qs[action] < 0){
          delay = 3
          //if(optimal.indexOf(this.env_structure.term_action.toString()) >= 0 || action == this.env_structure.term_action){
          if(!this.dummy_tutor && action == this.env_structure.term_action){
            var max_delay = 4
            var scaled = (max_delay / this.max_q_value)*v//(this.max_q_value - (this.max_q_value - v)) // scale delay based on best action observed in the environment
            delay = Math.round(Math.min(Math.max(0, scaled), max_delay)) // Clamp between 3 and 40
            delay += 3 
          }
          else{
            delay = 3
          }
        } else {
          delay = 0;
        }
      } else {
        return;
      }
      if (this.show_feedback) {
        this.reset_choice_highlight()
        defaultMessage = "";
        this.prompt.html(defaultMessage);
        //oldFeedbackMessage = @prompt.html()
        if (loss < tolerance && qs[action] >= 0){ //loss === 0) {
          msg = "Good job!";
          if(this.show_choice_options && action != this.termAction){
            msg += `<br>The next selection will load in ${2} seconds.`;
          }
          this.prompt.html(`<div align='center' style='padding-top:60px; color:#008800; font-weight:bold; font-size:18pt'>\n${msg}\n</div>`);
          if(this.show_choice_options && action != this.termAction){
            await sleep(2 * 1000);
          }
          // Count correct clicks
          this.data["choice-feedback"].push(1)
        } else {
          this.data["choice-feedback"].push(0)
          if (this.dummy_tutor && action == this.env_structure.term_action){
            msg = `Make ${this.minimum_clicks - this.data.queries.click.state.target.length} more choices before terminating.`;
            msg += `<br> Please wait ${delay} seconds.`;
            this.prompt.html(`<div align='center' style='padding-top:60px; color:#FF0000; font-weight:bold; font-size:18pt'>\n${msg}\n</div>`);
            await sleep(delay * 1000);
            this.prompt.html(defaultMessage);
          }
          else if (action == this.env_structure.term_action){
            msg = `Make some more choices before terminating.`;
            msg += `<br> Please wait ${delay} seconds.`;
            this.prompt.html(`<div align='center' style='padding-top:60px; color:#FF0000; font-weight:bold; font-size:18pt'>\n${msg}\n</div>`);
            await sleep(delay * 1000);
            this.prompt.html(defaultMessage);
          }
          else if ((ref = this.termAction, indexOf.call(optimal, ref) >= 0)) {
            msg = "You shouldn't have inspected any more nodes.";
            msg += `<br> Please wait ${delay} seconds.`;
            this.prompt.html(`<div align='center' style='padding-top:60px; color:#FF0000; font-weight:bold; font-size:18pt'>\n${msg}\n</div>`);
            await sleep(delay * 1000);
            this.prompt.html(defaultMessage);
          } 
          else {
            if(this.choice.length == 2){
              msg = "You should have inspected the other highlighted node instead.";
            }
            else{
              msg = "You should have inspected another highlighted node instead.";
            }
            for (i = 0, len = optimal.length; i < len; i++) {
              a = optimal[i];
              this.states[a].circle.set('fill', '#49f');
              this.canvas.renderAll();
            }
            msg += `<br> Please wait ${delay} seconds.`;
            this.prompt.html(`<div align='center' style='padding-top:60px; color:#FF0000; font-weight:bold; font-size:18pt'>\n${msg}\n</div>`);
            await sleep(delay * 1000);
            this.prompt.html(defaultMessage);
          }
          // Count incorrect clicks
          // if(action == this.env_structure.term_action){
          //   // Minimum 1 mistake
          //   var missing = Math.max(this.n_actions.length - this.data.queries.click.state.target.length, 1)
          //   for(var x=0;x<missing; x++){
          //     this.data["choice-feedback"].push(0)
          //   }
          // }
        }
      } else {
        console.log('no');
      }
      this.freeze = false;
      if (ref1 = this.termAction, indexOf.call(optimal, ref1) < 0) {
        for (j = 0, len1 = optimal.length; j < len1; j++) {
          s = optimal[j];
          this.states[s].circle.set('fill', '#bbb');
        }
        this.canvas.renderAll()
      }
      return delay
    }

    async generate_choice(){
      this.freeze = true
      var qs = await this.compute_qs()
      
      var term_val = qs[this.env_structure.term_action]
      delete qs[this.env_structure.term_action]

      var max_val = _.max(qs)

      // Compute set of different q values within the tolerance to the optimal q value
      var set_qs = [...new Set(Object.values(qs))]
      var unique_qs = [max_val]
      for(var q of set_qs){
        if(Math.abs(max_val - q) > this.q_tolerance){
          unique_qs.push(q)
        }
      }
      //console.log("Unique q values", unique_qs)

      // List action choices per unique q value
      var action_choices = {}
      for(var q of unique_qs){
        action_choices[q] = []
        for(var action of Object.keys(qs)){
          if(qs[action] == q){
            action_choices[q].push(action)
          }
        }
      }

      // Choices to store in format action: q_value
      var choices = {}

      // Number of choices = level + 1
      if(unique_qs.length <= this.tutor_level()){
        // Select one action per distinct q value
        for(var q of unique_qs){
          var action = _.sample(action_choices[q])
          choices[action] = q
        }
        // Check how many actions still need to be selected - these will be drawn from existing q values
        var remaining_choices = this.tutor_level()-unique_qs.length+1
        var remaining_actions = []
        for(var action of Object.keys(qs)){
          if(action != this.env_structure.term_action && !Object.keys(choices).includes(action)){
            remaining_actions.push(action)
          } 
        }
        var added_actions = _.sample(remaining_actions, remaining_choices)
        
        for(action of added_actions){
          choices[action] = qs[action]
        }
        //console.log("Adding", added_actions, "from the pool of available actions", remaining_actions)
        //console.log("Final choices", choices)
      }
      else{
        // Choose required number of actions including the optimal action
        var max_action = _.sample(action_choices[max_val])
        choices[max_action] = max_val
        unique_qs.splice(unique_qs.indexOf(max_val), 1) // remove value from array
        for(var i = 0; i < this.tutor_level(); i++){
          var selected_q = _.sample(unique_qs)//_.min(unique_qs)
          var action = _.sample(action_choices[selected_q])
          choices[action] = selected_q
          unique_qs.splice(unique_qs.indexOf(selected_q), 1)
        }
      }

      // var max_actions = []
      // var min_actions = []
      // for(let action of Object.keys(qs)){
      //   if(qs[action]==max_val){
      //     max_actions.push(action)
      //   }
      //   if(qs[action]==min_val){
      //     min_actions.push(action)
      //   }
      // }
      // console.log("Best actions", max_actions, max_val, _.sample(max_actions))
      // console.log("Worst actions", min_actions, min_val, _.sample(min_actions))
      // console.log("Term action", this.env_structure.term_action, term_val)
      // var max_sample = _.sample(max_actions)
      // var min_sample = _.sample(min_actions)
      // var term_action = this.env_structure.term_action
      
      // choices[max_sample] = max_val
      // choices[min_sample] = min_val
      
      var msg = "Choose one of the highlighted blue nodes<br>or start moving.";
      for(var a of Object.keys(choices)){
        this.states[a].circle.set('fill', '#95c5ff');
        this.canvas.renderAll();
      }
      this.prompt.html(`<div align='center' style='padding-top:60px; color:#49f; font-weight:bold; font-size:18pt'>\n${msg}\n</div>`);

      // Add term action after rendering
      choices[this.env_structure.term_action] = term_val
      //console.log(choices)
      this.choice = choices
      this.freeze = false
      return
    }

    generate_dummy_actions(){
      var selected_group = _.sample(this.reward_groups)
      if(selected_group.length>=2){
        var selected_choices = _.sample(selected_group, 2)
      } 
      else{
        // Add random other node to choices
        var available_choices = []
        for(var action of Object.keys(this.samples)){
          if(this.samples[action].length>0 && action!=selected_group[0]){
            available_choices.push(parseInt(action))
          }
        }
        var selected_choices = _.sample(available_choices, 1)
        selected_choices.push(selected_group[0])
      }
      return selected_choices
    }

    async generate_dummy_choice(){
      this.freeze = true

      var selected_choices = this.generate_dummy_actions()
      
      //console.log("Selected Group", selected_group)
      //console.log("Selected Choice", selected_choices)
      
      // Choices to store in format action: q_value
      var choices = {}
      
      if(this.data.queries.click.state.target.length < this.minimum_clicks){
        if(Math.round(Math.random())){
          choices[selected_choices[0]] = 1
          choices[selected_choices[1]] = 0
        }
        else{
          choices[selected_choices[0]] = 0
          choices[selected_choices[1]] = 1
        }
      }
      else{
        choices[selected_choices[0]] = 0
        choices[selected_choices[1]] = 0
      }
      
      if(this.data.queries.click.state.target.length < this.minimum_clicks){
        var msg = "Choose one of the highlighted blue nodes.";
      }
      else{
        var msg = "Start moving now.";
        choices = {}
      }
      for(var a of Object.keys(choices)){
        this.states[a].circle.set('fill', '#95c5ff');
        this.canvas.renderAll();
      }
      this.prompt.html(`<div align='center' style='padding-top:60px; color:#49f; font-weight:bold; font-size:18pt'>\n${msg}\n</div>`);

      // Add term action after rendering
      choices[this.env_structure.term_action] = 0
      if(this.data.queries.click.state.target.length < this.minimum_clicks){
        choices[this.env_structure.term_action] = 0
      }
      else{
        choices[this.env_structure.term_action] = 1
      }
      
      //console.log(choices)
      this.choice = choices
      this.freeze = false
      return
    }

    reset_choice_highlight(){
      this.prompt.html("");
      for (var a of Object.keys(this.choice)) {
        if(a != this.env_structure.term_action){
          this.states[a].circle.set('fill', '#bbb')
        }
      }
      this.canvas.renderAll()
    }

    mouseoverState(g, s) {
      // LOG_DEBUG "mouseoverState #{s}"
      if (this.stateLabels && this.stateDisplay === 'hover') {
        // webppl.run('flip()', (s, x) -> g.setLabel (Number x))
        g.setLabel(this.stateLabels[s]);
        return this.recordQuery('mouseover', 'state', s);
      }
    }

    mouseoutState(g, s) {
      // LOG_DEBUG "mouseoutState #{s}"
      if (this.stateLabels && this.stateDisplay === 'hover') {
        g.setLabel('');
        return this.recordQuery('mouseout', 'state', s);
      }
    }

    clickEdge(g, s0, r, s1) {
      var ref;
      if (!this.complete && g.label.text === '?') {
        LOG_DEBUG(`clickEdge ${s0} ${r} ${s1}`);
        if (this.edgeLabels && this.edgeDisplay === 'click' && ((ref = g.label.text) === '?' || ref === '')) {
          g.setLabel(this.getEdgeLabel(s0, r, s1));
          return this.recordQuery('click', 'edge', `${s0}__${s1}`);
        }
      }
    }

    mouseoverEdge(g, s0, r, s1) {
      // LOG_DEBUG "mouseoverEdge #{s0} #{r} #{s1}"
      if (this.edgeLabels && this.edgeDisplay === 'hover') {
        g.setLabel(this.getEdgeLabel(s0, r, s1));
        return this.recordQuery('mouseover', 'edge', `${s0}__${s1}`);
      }
    }

    mouseoutEdge(g, s0, r, s1) {
      // LOG_DEBUG "mouseoutEdge #{s0} #{r} #{s1}"
      if (this.edgeLabels && this.edgeDisplay === 'hover') {
        g.setLabel('');
        return this.recordQuery('mouseout', 'edge', `${s0}__${s1}`);
      }
    }

    getEdgeLabel(s0, r, s1) {
      if (this.edgeLabels === 'reward') {
        return '®';
      } else {
        return this.edgeLabels[`${s0}__${s1}`];
      }
    }

    recordQuery(queryType, targetType, target) {
      this.canvas.renderAll();
      // LOG_DEBUG "recordQuery #{queryType} #{targetType} #{target}"
      // @data["#{queryType}_#{targetType}_#{target}"]
      this.data.queries[queryType][targetType].target.push(target);
      //console.log("Time", Date.now() - this.initTime)
      return this.data.queries[queryType][targetType].time.push(Date.now() - this.initTime);
    }

    getStateDisplay(s, mode){
      if(s==="0"){
        return this.stateRewards[s]
      }
      switch(mode){
        case "trueReward":
          return round(this.stateRewards[s])
        case "lastObservation":
          s = parseInt(s)
          if(s in this.state_samples){
            return round(this.state_samples[s][this.state_samples[s].length - 1])
          }
          else {
            return 0
          }
        case "meanObservation":
          s = parseInt(s)
          if(s in this.state_samples){
            return round(this.state_samples[s].reduce((a,b) => a + b, 0) / this.state_samples[s].length)
          }
          else {
            return 0
          }
        case "posteriorMean":
          return round(this.state_dist[s][0])
        default:
          console.log("Invalid state display mode:", this.stateDisplayMode)
          return round(this.stateRewards[s])
      }
    }

    arrive(s, repeat = false) {
      var a, g, keys;
      g = this.states[s];
      // Lovis: clear old observations
      if(this.partialObservability){
        this.canvas.remove(g.label)
      }
      g.setLabel(this.getStateDisplay(s, this.moveDisplayMode))
      //g.setLabel(this.stateRewards[s]);
      this.canvas.renderAll();
      this.freeze = false;
      LOG_DEBUG('arrive', s);
      if (!repeat) { // sending back to previous state
        this.data.path.push(s);
      }
      // Get available actions.
      if (this.graph[s]) {
        keys = (function() {
          var i, len, ref, results;
          ref = Object.keys(this.graph[s]);
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            a = ref[i];
            results.push(this.keys[a]);
          }
          return results;
        }).call(this);
      } else {
        keys = [];
      }
      if (this.allowSimulation) {
        keys.push('space');
      }
      if (!keys.length) {
        this.complete = true;
        this.checkFinished();
        return;
      }

      if (!mdp.showDemo && !mdp.poDemo) {
        // Start key listener.
        return this.keyListener = jsPsych.pluginAPI.getKeyboardResponse({
          valid_responses: keys,
          rt_method: 'performance',
          persist: false,
          allow_held_key: false,
          callback_function: (info) => {
            var action;
            action = this.invKeys[info.key];
            if(keys.includes(info.key) && !this.freeze){
              LOG_DEBUG('key', info.key);
              this.data.rt.push(info.rt);
              return this.handleKey(s, action);
            }
            let message = 'Invalid Direction';
            this.displayFeedback(message, false, 1);
            return this.arrive(s, true);
          }
        });
      }
    }

    async displayFeedback(feedback, positive, duration = 4){
      this.lowerMessage.html("<div id='feedback' style='font-weight:bold; font-size:16pt'/>");
      $('#feedback').html(feedback);
      positive ? $('#feedback').css('color', '#080') : $('#feedback').css('color', 'red');

      var self = this;
      clearInterval(this.feedback_timeout);
      this.feedback_timeout = setTimeout(function(){self.lowerMessage.html(self.defaultLowerMessage);}, duration * 1000);
    }

    addScore(v) {
      // Lovis fixed float inaccuracies
      var score;
      this.data.score = Number((this.data.score + v).toFixed(2));
      if (this.simulationMode) {
        score = this.data.score;
      } else {
        SCORE += v;
        SCORE = Number((SCORE).toFixed(2));
        score = SCORE;
      }
      return this.drawScore(score);
    }

    resetScore() {
      this.data.score = 0;
      return this.drawScore(SCORE);
    }

    drawScore(score) {
      $('#mouselab-score').html('$' + score);
      return $('#mouselab-score').css('color', redGreen(score));
    }

    run() {
      // document.body.style.cursor = 'crosshair'
      jsPsych.pluginAPI.cancelAllKeyboardResponses();
      LOG_DEBUG('run');
      if(this.showImage){
        console.log("helloworld");
      }
      this.buildMap();
      if (this.timeLimit || this.minTime) {
        this.startTimer();
      }
      fabric.Image.fromURL(this.playerImage, ((img) => {
        this.initPlayer(img);
        this.canvas.renderAll();
      }));
      fabric.Image.fromURL(this.ExtraImage, ((img) => {
        this.initExtraImage(img)
        this.initTime = Date.now();
        //this.states[37].setLabel("0"); //frederic
        return this.arrive(this.initial);
      }));
      if (this.showDemo) {
        return this.runDemo();
      }
      if (this.poDemo && this.dummy_tutor){
        return this.runDummyPODemo();
      }
      if (this.poDemo){
        return this.runPODemo();
      }
      if (this.show_choice_options){
        if(this.dummy_tutor){
          this.generate_dummy_choice()
        }
        else{
          this.generate_choice()
        }
      }
    }

    draw(obj) {
      this.canvas.add(obj);
      return obj;
    }

    extra_draw(obj)
    {
      this.extra_canvas.add(obj);
      return obj;
    }

    initPlayer(img) {
      var left, top;
      LOG_DEBUG('initPlayer');
      top = this.states[this.initial].top + TOP_ADJUST;
      left = this.states[this.initial].left;
      img.scale(0.22);
      img.set('top', top).set('left', left);
      this.draw(img);
      return this.player = img;
    }

    initExtraImage(img) {
      var left, top;
      LOG_DEBUG('initExtra');
      top = this.states[this.initial].top + EXTRA_TOP_ADJUST;
      left = this.states[this.initial].left+ EXTRA_LEFT_ADJUST;
      img.scale(0.50);
      img.set('top', top).set('left', left);
      this.extra_draw(img);
      return this.extra_image = img;
    }

    buildMap() {
      var a, actions, height, location, maxx, maxy, minx, miny, r, ref, ref1, results, s, s0, s1, width, x, xs, y, ys;

      if(this.showImage){

      [width, height] = [2.5, 3];
      this.ExtracanvasElement.attr({
        width: width * SIZE,
        height: (height) * SIZE
      });
      this.extra_canvas = new fabric.Canvas('mouselab-canvas2', {
        selection: false
      });
      }

      if(!this.showImage){
      [width, height] = [0, 0];
      this.ExtracanvasElement.attr({
        width: width * SIZE,
        height: height * SIZE
      });
      this.extra_canvas = new fabric.Canvas('mouselab-canvas2', {
        selection: false
      });
      }

      [xs, ys] = _.unzip(_.values(this.layout));
      minx = _.min(xs);
      miny = _.min(ys);
      maxx = _.max(xs);
      maxy = _.max(ys);
      miny = miny + (TOP_ADJUST/SIZE);
      [width, height] = [maxx - minx + 1, maxy - miny + 1];

      this.canvasElement.attr({
        width: width * SIZE,
        height: height * SIZE
      });
      this.canvas = new fabric.Canvas('mouselab-canvas', {
        selection: false
      });
      this.canvas.defaultCursor = 'pointer';
      this.extra_canvas.defaultCursor = 'pointer';
      this.states = {};
      ref = removePrivate(this.layout);
      for (s in ref) {
        location = ref[s];
        [x, y] = location;
        this.states[s] = new State(s, x - minx, y - miny, {
          fill: '#bbb',
          label: this.stateDisplay === 'always' ? this.stateLabels[s] : ''
        });
      }

      ref1 = removePrivate(this.graph);
      results = [];
      for (s0 in ref1) {
        actions = ref1[s0];
        results.push((function() {
          var results1 = [];
          let map = {"left": 1, "up": 2, "right": 3, "farright": 4};

          for (a in actions) {
            [r, s1] = actions[a];
            let label = map[a];

            results1.push(new Edge(this.states[s0], r, this.states[s1], {
              label: this.edgeDisplay === 'always' ? label : ''
            }));
          }
          return results1;
        }).call(this));
      }

      //frederic destroy and rebuild to place circles in the front
      for(s in this.states){
        this.states[s].destroy();
      }
      this.states = {};
      ref = removePrivate(this.layout);
      for (s in ref) {
        location = ref[s];
        [x, y] = location;
        this.states[s] = new State(s, x - minx, y - miny, {
          fill: '#bbb',
          label: this.stateDisplay === 'always' ? this.stateLabels[s] : ''
        });
      }

      //frederic unlock predefined
      //console.log(this.revealed);
      if(this.revealed != null){
        for(let s of this.revealed){
          this.recordQuery('click', 'state', s);
          this.states[parseInt(s)].setLabel(this.stateLabels[s]);
        }
      }

      return results;
    }

    endTrial(show_money_made = true) {
      window.clearInterval(this.timerID);
      if (this.blockOver) {
        return;
      }
      // frederic
      if(show_money_made){
        this.lowerMessage.html("<br>You made <span class=mouselab-score/> on this round.\n<br>\n<b>Press</b> <code>space</code> <b>to continue.</b>");
        $('.mouselab-score').html('$' + this.data.score);
        $('.mouselab-score').css('color', redGreen(this.data.score));
        $('.mouselab-score').css('font-weight', 'bold');
      }else{
        this.lowerMessage.html("<b>Press</b> <code>space</code> <b>to continue.</b>");
      }
      return this.keyListener = jsPsych.pluginAPI.getKeyboardResponse({
        valid_responses: [' '],
        rt_method: 'performance',
        persist: false,
        allow_held_key: false,
        callback_function: (info) => {
          this.data.trialTime = getTime() - this.initTime;
          this.display.innerHTML = '';
          return jsPsych.finishTrial(this.data);
        }
      });
    }

    checkFinished() {
      if (this.complete) {
        if (this.timeLeft != null) {
          if (this.timeLeft > 0) {
            return this.waitMessage.show();
          } else {
            this.waitMessage.hide();
            return this.endTrial();
          }
        } else {
          return this.endTrial();
        }
      }
    }

  };

  //  =========================== #
  //  ========= Graphics ========= #
  //  =========================== #
  State = class State {
    constructor(name, left, top, config = {}) {
      var conf;
      this.name = name;
      left = (left + 0.5) * SIZE;
      top = (top + 0.5) * SIZE;
      this.left = left;
      this.top = top;
      conf = {
        left: left,
        top: top,
        fill: '#bbbbbb',
        radius: SIZE / 4,
        label: ''
      };
      _.extend(conf, config);
      // Due to a quirk in Fabric, the maximum width of the label
      // is set when the object is initialized (the call to super).
      // Thus, we must initialize the label with a placeholder, then
      // set it to the proper value afterwards.
      this.circle = new fabric.Circle(conf);
      this.circle.set('transition', '0.3s');
      this.label = {};
      // @label = new Text '----------', left, top,
      //   fontSize: SIZE / 4
      //   fill: '#44d'
      this.radius = this.circle.radius;
      this.left = this.circle.left;
      this.top = this.circle.top;
      mdp.canvas.add(this.circle);

      // @setLabel conf.label
      if (!mdp.showDemo && !mdp.poDemo) {
        this.circle.on('mousedown', (event) => {
          return mdp.clickState(this, this.name);
        });
        this.circle.on('mouseover', (event) => {
          disablepan = true // Lovis
          return mdp.mouseoverState(this, this.name);
        });
        this.circle.on('mouseout', (event) => {
          disablepan = false
          return mdp.mouseoutState(this, this.name);
        });
      }
    }

    setLabel(txt, conf = {}) {
      var post, pre;
      this.label = new Text('----------', this.left, this.top, {
        fontSize: SIZE / 4,
        fill: '#44d'
      });
      ({pre = '', post = ''} = conf);
      // LOG_DEBUG "setLabel #{txt}"
      if (txt != null) {
        this.label.setText(`${pre}${txt}${post}`);
        this.label.setFill(redGreen(txt));
      } else {
        this.label.setText('');
      }
      mdp.canvas.add(this.label);
      LOG_DEBUG('setLabel', txt);
      // Lovis - allow states to be clicked multiple times by adding the onclick event to the text as well
      if (mdp.partialObservability && !mdp.showDemo && !mdp.poDemo) {
        this.label.on('mousedown', () => {
          return mdp.clickState(this, this.name);
        });
        this.label.on('mouseover', () => {
          return mdp.mouseoverState(this, this.name);
        });
        this.label.on('mouseout', () => {
          return mdp.mouseoutState(this, this.name);
        });
      }
      return this.dirty = true;
    }

    higlight() {
      return this.circle.set('color', '#49f');
    }

    destroy(){
      mdp.canvas.remove(this.label);
      mdp.canvas.remove(this.circle);
    }
    animateClick(){
      var prev_color = this.circle.get('fill');
      var self = this;

      this.circle.set('fill', '#edebeb');
      setTimeout(function(){self.circle.set('fill',prev_color)},0.5)
    }

  };
  Edge = class Edge {
    constructor(c1, reward, c2, config = {}) {
      var adjX, adjY, ang, labX, labY, label, rotateLabel, spacing, x1, x2, y1, y2;
      ({spacing = 4, adjX = 0, adjY = 0, rotateLabel = false, label = ''} = config); //frederic
      [x1, y1, x2, y2] = [c1.left + adjX, c1.top + adjY, c2.left + adjX, c2.top + adjY];
      this.arrow = new Arrow(x1, y1, x2, y2, c1.radius + spacing, c2.radius + spacing);
      ang = (this.arrow.ang + Math.PI / 2) % (Math.PI * 2);
      if ((0.5 * Math.PI <= ang && ang <= 1.5 * Math.PI)) {
        ang += Math.PI;
      }
      let len = Math.sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2));
      [labX, labY] = polarMove(x1, y1, angle(x1, y1, x2, y2), Math.max(0.17 * len, SIZE * 0.45));
      // See note about placeholder in State.
      this.label = new Text('----------', labX, labY, {
        angle: rotateLabel ? ang * 180 / Math.PI : 0,
        fill: '#bbbbbb',
        fontSize: SIZE / 4,
        textBackgroundColor: 'white'
      });
      this.arrow.on('mousedown', () => {
        return mdp.clickEdge(this, c1.name, reward, c2.name);
      });
      this.arrow.on('mouseover', () => {
        return mdp.mouseoverEdge(this, c1.name, reward, c2.name);
      });
      this.arrow.on('mouseout', () => {
        return mdp.mouseoutEdge(this, c1.name, reward, c2.name);
      });
      this.setLabel(label);
      mdp.canvas.add(this.arrow);
      mdp.canvas.add(this.label);
    }

    setLabel(txt, conf = {}) {
      var post, pre;
      ({pre = '', post = ''} = conf);
      // LOG_DEBUG "setLabel #{txt}"
      if (txt) {
        this.label.setText(`${pre}${txt}${post}`);
        this.label.setFill('#555');
      } else {
        this.label.setText('');
      }
      return this.dirty = true;
    }

  };
  Arrow = class Arrow extends fabric.Group {
    constructor(x1, y1, x2, y2, adj1 = 0, adj2 = 0) {
      var ang, centerX, centerY, deltaX, deltaY, dx, dy, line, point;
      ang = angle(x1, y1, x2, y2);
      [x1, y1] = polarMove(x1, y1, ang, adj1);
      [x2, y2] = polarMove(x2, y2, ang, -(adj2 + 7.5));
      line = new fabric.Line([x1, y1, x2, y2], {
        stroke: '#555',
        selectable: false,
        strokeWidth: 2
      });
      centerX = (x1 + x2) / 2;
      centerY = (y1 + y2) / 2;
      deltaX = line.left - centerX;
      deltaY = line.top - centerY;
      dx = x2 - x1;
      dy = y2 - y1;
      point = new fabric.Triangle({
        left: x2 + deltaX,
        top: y2 + deltaY,
        pointType: 'arrow_start',
        angle: ang * 180 / Math.PI,
        width: 10,
        height: 10,
        fill: '#555'
      });
      super([line, point]);
      this.ang = ang;
      this.centerX = centerX;
      this.centerY = centerY;
    }

  };
  Text = class Text extends fabric.Text {
    constructor(txt, left, top, config) {
      var conf;
      txt = String(txt);
      conf = {
        left: left,
        top: top,
        fontFamily: 'helvetica',
        fontSize: SIZE / 8
      };
      _.extend(conf, config);
      super(txt, conf);
    }

  };
  // ================================= #
  // ========= jsPsych stuff ========= #
  // ================================= #
  plugin = {
    info: {
      name: 'mouselab-mdp',
      description: '',
      parameters: {}
    },
    trial: function(display_element, trialConfig) {
      console.log("TRIAL")
      var trial;
      // trialConfig = jsPsych.pluginAPI.evaluateFunctionParameters trialConfig, ['_init', 'constructor']
      trialConfig.display = display_element;
      //LOG_INFO('trialConfig', trialConfig);
      trial = new MouselabMDP(trialConfig);
      trial.run();

      // Lovis
      // Canvas resize to fit screen
      if(trial.panUser || trial.panDemo){
        var offset_x = 0;
        var offset_y = 0;
        if(trial.canvas.width > 1200){
          offset_x = trial.canvas.width - 1200;
          trial.canvas.setWidth(1200);
        }
        if(trial.canvas.height > 500){
          offset_y = trial.canvas.height - 500;
          trial.canvas.setHeight(500);
        }
        trial.canvas.absolutePan({ x: offset_x / 2, y: offset_y + 10});
        trial.canvas.renderAll();
      }
      
      // Panning functionality (Lovis)
      // Enable by passing the MDP parameters panUser and panDemo
      if(trial.panUser){
        trial.canvas.on('mouse:wheel', (opt) => {
          var delta = opt.e.deltaY;
          var zoom = trial.canvas.getZoom();
          zoom *= 0.999 ** delta;
          if (zoom > 3) zoom = 3;
          if (zoom < 0.1) zoom = 0.1;
          trial.canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
          opt.e.preventDefault();
          opt.e.stopPropagation();
        });
        var panning = false
        trial.canvas.on('mouse:up', (e) => {
          panning = false;
        });
        trial.canvas.on('mouse:down', (e) => {
          if(!disablepan){
            panning = true;
          }
        });
        trial.canvas.on('mouse:move', (e) => {
            if (panning && e && e.e) {
                var delta = new fabric.Point(e.e.movementX, e.e.movementY);
                trial.canvas.relativePan(delta);
            }
        });
        var button = document.createElement("input");
        button.type = "button";
        button.value = "Reset position";
        button.addEventListener('click', () => {
          trial.canvas.setViewportTransform([1,0,0,1,0,0]); 
        })
        document.getElementById('mouselab-msg-center').appendChild(button);
      }
      
      
      if (trialConfig._block) {
        trialConfig._block.trialCount += 1;
      }
      return TRIAL_INDEX += 1;
    }
  };
  return plugin;
})();
